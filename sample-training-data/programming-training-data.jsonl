{"messages": [{"role": "system", "content": "You are an expert Python programmer and teacher. Provide clear, well-commented code examples with explanations."}, {"role": "user", "content": "How do I read a CSV file in Python and calculate the average of a numeric column?"}, {"role": "assistant", "content": "Great question! There are several ways to read CSV files in Python. I'll show you two popular methods: using the built-in `csv` module and using `pandas`.\n\n**Method 1: Using pandas (Recommended for data analysis):**\n```python\nimport pandas as pd\n\n# Read the CSV file\ndf = pd.read_csv('your_file.csv')\n\n# Calculate average of a specific column\naverage = df['column_name'].mean()\n\nprint(f\"Average: {average}\")\n```\n\n**Method 2: Using built-in csv module:**\n```python\nimport csv\n\n# Read CSV and calculate average\ntotal = 0\ncount = 0\n\nwith open('your_file.csv', 'r') as file:\n    reader = csv.DictReader(file)\n    \n    for row in reader:\n        # Convert string to float and add to total\n        total += float(row['column_name'])\n        count += 1\n\naverage = total / count\nprint(f\"Average: {average}\")\n```\n\n**Key Points:**\n- Pandas is more powerful for data manipulation\n- Built-in csv module is lighter for simple operations\n- Always handle potential errors (empty files, non-numeric data)\n\nWould you like me to show you how to handle missing values or errors?"}]}
{"messages": [{"role": "system", "content": "You are an expert Python programmer and teacher. Provide clear, well-commented code examples with explanations."}, {"role": "user", "content": "How do I create a simple web API using Flask?"}, {"role": "assistant", "content": "Flask is perfect for creating simple web APIs! Let me show you how to build a basic API step by step.\n\n**1. First, install Flask:**\n```bash\npip install flask\n```\n\n**2. Create a basic API (app.py):**\n```python\nfrom flask import Flask, jsonify, request\n\n# Create Flask application\napp = Flask(__name__)\n\n# Sample data\nusers = [\n    {'id': 1, 'name': 'John Doe', 'email': 'john@example.com'},\n    {'id': 2, 'name': 'Jane Smith', 'email': 'jane@example.com'}\n]\n\n# GET all users\n@app.route('/api/users', methods=['GET'])\ndef get_users():\n    return jsonify({'users': users})\n\n# GET specific user\n@app.route('/api/users/<int:user_id>', methods=['GET'])\ndef get_user(user_id):\n    user = next((u for u in users if u['id'] == user_id), None)\n    if user:\n        return jsonify({'user': user})\n    return jsonify({'error': 'User not found'}), 404\n\n# POST new user\n@app.route('/api/users', methods=['POST'])\ndef create_user():\n    data = request.get_json()\n    \n    new_user = {\n        'id': len(users) + 1,\n        'name': data.get('name'),\n        'email': data.get('email')\n    }\n    \n    users.append(new_user)\n    return jsonify({'user': new_user}), 201\n\nif __name__ == '__main__':\n    app.run(debug=True)\n```\n\n**3. Run the application:**\n```bash\npython app.py\n```\n\nYour API will be available at `http://localhost:5000/api/users`\n\n**Testing the endpoints:**\n- GET all users: `curl http://localhost:5000/api/users`\n- GET user by ID: `curl http://localhost:5000/api/users/1`\n- POST new user: `curl -X POST -H \"Content-Type: application/json\" -d '{\"name\":\"Bob\",\"email\":\"bob@example.com\"}' http://localhost:5000/api/users`\n\nWould you like me to show you how to add authentication or connect to a database?"}]}
{"messages": [{"role": "system", "content": "You are an expert Python programmer and teacher. Provide clear, well-commented code examples with explanations."}, {"role": "user", "content": "How can I handle exceptions properly in Python?"}, {"role": "assistant", "content": "Exception handling is crucial for writing robust Python code! Let me show you the best practices with clear examples.\n\n**Basic Exception Handling:**\n```python\ntry:\n    # Code that might raise an exception\n    number = int(input(\"Enter a number: \"))\n    result = 10 / number\n    print(f\"Result: {result}\")\nexcept ValueError:\n    print(\"Invalid input! Please enter a valid number.\")\nexcept ZeroDivisionError:\n    print(\"Cannot divide by zero!\")\nexcept Exception as e:\n    print(f\"An unexpected error occurred: {e}\")\nelse:\n    print(\"Operation completed successfully!\")\nfinally:\n    print(\"This always runs, regardless of exceptions\")\n```\n\n**Multiple Exception Types:**\n```python\ndef safe_file_operation(filename):\n    try:\n        with open(filename, 'r') as file:\n            data = file.read()\n            return json.loads(data)\n    except FileNotFoundError:\n        print(f\"File {filename} not found\")\n        return None\n    except PermissionError:\n        print(f\"Permission denied to read {filename}\")\n        return None\n    except json.JSONDecodeError:\n        print(f\"Invalid JSON in {filename}\")\n        return None\n    except (IOError, OSError) as e:\n        print(f\"File operation error: {e}\")\n        return None\n```\n\n**Custom Exceptions:**\n```python\nclass CustomValidationError(Exception):\n    \"\"\"Custom exception for validation errors\"\"\"\n    def __init__(self, message, error_code=None):\n        super().__init__(message)\n        self.error_code = error_code\n\ndef validate_email(email):\n    if '@' not in email:\n        raise CustomValidationError(\n            \"Invalid email format\", \n            error_code=\"INVALID_EMAIL\"\n        )\n    return True\n\n# Using custom exception\ntry:\n    validate_email(\"invalid-email\")\nexcept CustomValidationError as e:\n    print(f\"Validation failed: {e}\")\n    print(f\"Error code: {e.error_code}\")\n```\n\n**Context Managers (Recommended):**\n```python\n# Automatic resource cleanup\nclass DatabaseConnection:\n    def __enter__(self):\n        print(\"Connecting to database...\")\n        return self\n    \n    def __exit__(self, exc_type, exc_val, exc_tb):\n        print(\"Closing database connection...\")\n        if exc_type:\n            print(f\"Exception occurred: {exc_val}\")\n        return False  # Don't suppress exceptions\n\n# Usage\nwith DatabaseConnection() as db:\n    # Database operations here\n    pass  # Connection automatically closed\n```\n\n**Best Practices:**\n\n**1. Be Specific with Exceptions:**\n```python\n# ❌ Too broad\ntry:\n    risky_operation()\nexcept Exception:\n    pass\n\n# ✅ Specific and informative\ntry:\n    risky_operation()\nexcept ValueError as e:\n    logger.error(f\"Invalid value provided: {e}\")\n    raise  # Re-raise if you can't handle it\nexcept TypeError as e:\n    logger.error(f\"Type error: {e}\")\n    return default_value\n```\n\n**2. Use Logging:**\n```python\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef process_data(data):\n    try:\n        # Process the data\n        result = complex_operation(data)\n        logger.info(\"Data processed successfully\")\n        return result\n    except ValueError as e:\n        logger.error(f\"Data validation failed: {e}\")\n        raise\n    except Exception as e:\n        logger.exception(\"Unexpected error during data processing\")\n        raise\n```\n\n**3. Exception Chaining:**\n```python\ndef convert_data(raw_data):\n    try:\n        return json.loads(raw_data)\n    except json.JSONDecodeError as e:\n        raise ValueError(\"Invalid data format\") from e\n\n# This preserves the original exception information\n```\n\n**Common Patterns:**\n\n**Retry Logic:**\n```python\nimport time\nimport random\n\ndef retry_operation(func, max_retries=3, delay=1):\n    for attempt in range(max_retries):\n        try:\n            return func()\n        except (ConnectionError, TimeoutError) as e:\n            if attempt == max_retries - 1:\n                raise e\n            time.sleep(delay * (2 ** attempt))  # Exponential backoff\n            continue\n```\n\n**Validation with Multiple Checks:**\n```python\ndef validate_user_data(user_data):\n    errors = []\n    \n    try:\n        if not user_data.get('email'):\n            errors.append(\"Email is required\")\n        elif '@' not in user_data['email']:\n            errors.append(\"Invalid email format\")\n            \n        if not user_data.get('age') or user_data['age'] < 0:\n            errors.append(\"Valid age is required\")\n            \n    except (KeyError, TypeError) as e:\n        errors.append(f\"Data structure error: {e}\")\n    \n    if errors:\n        raise ValidationError(\"; \".join(errors))\n    \n    return True\n```\n\n**Key Takeaways:**\n- Catch specific exceptions, not generic ones\n- Always log errors appropriately\n- Use `finally` for cleanup code\n- Consider using context managers for resource management\n- Don't swallow exceptions unless you can properly handle them\n\nWhat specific exception handling scenario are you working with? I can provide more targeted examples!"}]}
{"messages": [{"role": "system", "content": "You are an expert Python programmer and teacher. Provide clear, well-commented code examples with explanations."}, {"role": "user", "content": "How do I work with databases in Python using SQLAlchemy?"}, {"role": "assistant", "content": "SQLAlchemy is an excellent choice for database work in Python! I'll show you both the Core and ORM approaches.\n\n**Installation:**\n```bash\npip install sqlalchemy\n# For specific databases:\npip install psycopg2-binary  # PostgreSQL\npip install pymysql          # MySQL\n```\n\n**1. Database Setup and Connection:**\n```python\nfrom sqlalchemy import create_engine, Column, Integer, String, DateTime, ForeignKey\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, relationship\nfrom datetime import datetime\n\n# Create engine (connection)\nengine = create_engine('sqlite:///example.db', echo=True)  # echo=True for SQL logging\n\n# Create base class for ORM models\nBase = declarative_base()\n\n# Create session factory\nSession = sessionmaker(bind=engine)\n```\n\n**2. Define Models (ORM Approach):**\n```python\nclass User(Base):\n    __tablename__ = 'users'\n    \n    id = Column(Integer, primary_key=True)\n    username = Column(String(50), unique=True, nullable=False)\n    email = Column(String(100), unique=True, nullable=False)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    \n    # Relationship to posts\n    posts = relationship(\"Post\", back_populates=\"author\")\n    \n    def __repr__(self):\n        return f\"<User(username='{self.username}', email='{self.email}')>\"\n\nclass Post(Base):\n    __tablename__ = 'posts'\n    \n    id = Column(Integer, primary_key=True)\n    title = Column(String(100), nullable=False)\n    content = Column(String(1000))\n    user_id = Column(Integer, ForeignKey('users.id'))\n    created_at = Column(DateTime, default=datetime.utcnow)\n    \n    # Relationship to user\n    author = relationship(\"User\", back_populates=\"posts\")\n    \n    def __repr__(self):\n        return f\"<Post(title='{self.title}')>\"\n\n# Create all tables\nBase.metadata.create_all(engine)\n```\n\n**3. CRUD Operations:**\n```python\ndef create_user(username, email):\n    \"\"\"Create a new user\"\"\"\n    session = Session()\n    try:\n        user = User(username=username, email=email)\n        session.add(user)\n        session.commit()\n        print(f\"User {username} created successfully!\")\n        return user\n    except Exception as e:\n        session.rollback()\n        print(f\"Error creating user: {e}\")\n        return None\n    finally:\n        session.close()\n\ndef get_user_by_id(user_id):\n    \"\"\"Retrieve user by ID\"\"\"\n    session = Session()\n    try:\n        user = session.query(User).filter(User.id == user_id).first()\n        return user\n    finally:\n        session.close()\n\ndef get_all_users():\n    \"\"\"Get all users\"\"\"\n    session = Session()\n    try:\n        users = session.query(User).all()\n        return users\n    finally:\n        session.close()\n\ndef update_user(user_id, **kwargs):\n    \"\"\"Update user information\"\"\"\n    session = Session()\n    try:\n        user = session.query(User).filter(User.id == user_id).first()\n        if user:\n            for key, value in kwargs.items():\n                if hasattr(user, key):\n                    setattr(user, key, value)\n            session.commit()\n            print(f\"User {user_id} updated successfully!\")\n            return user\n        else:\n            print(f\"User {user_id} not found\")\n            return None\n    except Exception as e:\n        session.rollback()\n        print(f\"Error updating user: {e}\")\n        return None\n    finally:\n        session.close()\n\ndef delete_user(user_id):\n    \"\"\"Delete a user\"\"\"\n    session = Session()\n    try:\n        user = session.query(User).filter(User.id == user_id).first()\n        if user:\n            session.delete(user)\n            session.commit()\n            print(f\"User {user_id} deleted successfully!\")\n            return True\n        else:\n            print(f\"User {user_id} not found\")\n            return False\n    except Exception as e:\n        session.rollback()\n        print(f\"Error deleting user: {e}\")\n        return False\n    finally:\n        session.close()\n```\n\n**4. Advanced Queries:**\n```python\ndef advanced_queries_examples():\n    session = Session()\n    \n    try:\n        # Filter with conditions\n        active_users = session.query(User).filter(\n            User.created_at > datetime(2024, 1, 1)\n        ).all()\n        \n        # Join queries\n        users_with_posts = session.query(User).join(Post).all()\n        \n        # Count posts per user\n        from sqlalchemy import func\n        post_counts = session.query(\n            User.username,\n            func.count(Post.id).label('post_count')\n        ).join(Post).group_by(User.id).all()\n        \n        # Complex filtering\n        popular_users = session.query(User).join(Post).group_by(User.id).having(\n            func.count(Post.id) > 5\n        ).all()\n        \n        # Ordering and limiting\n        recent_posts = session.query(Post).order_by(\n            Post.created_at.desc()\n        ).limit(10).all()\n        \n        return {\n            'active_users': active_users,\n            'users_with_posts': users_with_posts,\n            'post_counts': post_counts,\n            'popular_users': popular_users,\n            'recent_posts': recent_posts\n        }\n        \n    finally:\n        session.close()\n```\n\n**5. Context Manager for Sessions:**\n```python\nfrom contextlib import contextmanager\n\n@contextmanager\ndef get_session():\n    \"\"\"Context manager for database sessions\"\"\"\n    session = Session()\n    try:\n        yield session\n        session.commit()\n    except Exception:\n        session.rollback()\n        raise\n    finally:\n        session.close()\n\n# Usage\ndef create_user_with_context(username, email):\n    with get_session() as session:\n        user = User(username=username, email=email)\n        session.add(user)\n        return user  # Automatically committed\n```\n\n**6. Raw SQL Queries (when needed):**\n```python\ndef execute_raw_sql():\n    \"\"\"Execute raw SQL when ORM is not sufficient\"\"\"\n    with get_session() as session:\n        # Raw query with parameters\n        result = session.execute(\n            \"SELECT username, email FROM users WHERE created_at > :date\",\n            {'date': datetime(2024, 1, 1)}\n        )\n        \n        users = result.fetchall()\n        return users\n```\n\n**7. Migration Example (Alembic integration):**\n```python\n# First, install alembic\n# pip install alembic\n\n# Initialize alembic in your project\n# alembic init alembic\n\n# In alembic/env.py, set target_metadata:\n# target_metadata = Base.metadata\n\n# Generate migration\n# alembic revision --autogenerate -m \"Initial migration\"\n\n# Apply migration\n# alembic upgrade head\n```\n\n**Usage Example:**\n```python\nif __name__ == \"__main__\":\n    # Create some users\n    user1 = create_user(\"john_doe\", \"john@example.com\")\n    user2 = create_user(\"jane_smith\", \"jane@example.com\")\n    \n    # Create posts\n    if user1:\n        with get_session() as session:\n            post1 = Post(title=\"My First Post\", content=\"Hello World!\", user_id=user1.id)\n            post2 = Post(title=\"Python Tips\", content=\"SQLAlchemy is awesome!\", user_id=user1.id)\n            session.add_all([post1, post2])\n    \n    # Query data\n    all_users = get_all_users()\n    print(f\"Total users: {len(all_users)}\")\n    \n    # Advanced queries\n    results = advanced_queries_examples()\n    print(f\"Post counts: {results['post_counts']}\")\n```\n\n**Best Practices:**\n\n1. **Always use sessions properly** (context managers recommended)\n2. **Handle exceptions and rollbacks**\n3. **Use relationships for complex queries**\n4. **Index frequently queried columns**\n5. **Use connection pooling for production**\n6. **Consider using Alembic for migrations**\n7. **Log SQL queries during development** (echo=True)\n\nWould you like me to explain any specific aspect in more detail, such as relationships, migrations, or performance optimization?"}]}
{"messages": [{"role": "system", "content": "You are an expert Python programmer and teacher. Provide clear, well-commented code examples with explanations."}, {"role": "user", "content": "How do I create and use decorators in Python?"}, {"role": "assistant", "content": "Decorators are a powerful Python feature that allow you to modify or extend functions without changing their code! Let me explain them step by step.\n\n**What are Decorators?**\nDecorators are functions that take another function as input and extend its behavior without explicitly modifying it.\n\n**Basic Decorator Structure:**\n```python\ndef my_decorator(func):\n    def wrapper(*args, **kwargs):\n        # Code before the function call\n        print(\"Before function execution\")\n        \n        # Call the original function\n        result = func(*args, **kwargs)\n        \n        # Code after the function call\n        print(\"After function execution\")\n        \n        return result\n    return wrapper\n\n# Using the decorator\n@my_decorator\ndef say_hello(name):\n    print(f\"Hello, {name}!\")\n\nsay_hello(\"Alice\")  # Outputs: Before, Hello Alice!, After\n```\n\n**Common Decorator Patterns:**\n\n**1. Timing Decorator:**\n```python\nimport time\nfrom functools import wraps\n\ndef timing_decorator(func):\n    @wraps(func)  # Preserves original function metadata\n    def wrapper(*args, **kwargs):\n        start_time = time.time()\n        result = func(*args, **kwargs)\n        end_time = time.time()\n        print(f\"{func.__name__} took {end_time - start_time:.4f} seconds\")\n        return result\n    return wrapper\n\n@timing_decorator\ndef slow_function():\n    \"\"\"A function that takes some time\"\"\"\n    time.sleep(1)\n    return \"Done!\"\n\nprint(slow_function())  # Shows execution time\n```\n\n**2. Logging Decorator:**\n```python\nimport logging\nfrom functools import wraps\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\ndef log_calls(func):\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        logger.info(f\"Calling {func.__name__} with args: {args}, kwargs: {kwargs}\")\n        try:\n            result = func(*args, **kwargs)\n            logger.info(f\"{func.__name__} returned: {result}\")\n            return result\n        except Exception as e:\n            logger.error(f\"{func.__name__} raised {type(e).__name__}: {e}\")\n            raise\n    return wrapper\n\n@log_calls\ndef divide(a, b):\n    return a / b\n\nresult = divide(10, 2)  # Logs the call and result\ntry:\n    divide(10, 0)  # Logs the exception\nexcept ZeroDivisionError:\n    pass\n```\n\n**3. Retry Decorator:**\n```python\nimport random\nimport time\nfrom functools import wraps\n\ndef retry(max_attempts=3, delay=1):\n    \"\"\"Decorator factory that creates a retry decorator\"\"\"\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            last_exception = None\n            \n            for attempt in range(max_attempts):\n                try:\n                    return func(*args, **kwargs)\n                except Exception as e:\n                    last_exception = e\n                    if attempt < max_attempts - 1:\n                        print(f\"Attempt {attempt + 1} failed: {e}. Retrying in {delay} seconds...\")\n                        time.sleep(delay)\n                    else:\n                        print(f\"All {max_attempts} attempts failed.\")\n            \n            raise last_exception\n        return wrapper\n    return decorator\n\n@retry(max_attempts=3, delay=0.5)\ndef unreliable_function():\n    \"\"\"Function that randomly fails\"\"\"\n    if random.random() < 0.7:  # 70% chance of failure\n        raise ConnectionError(\"Network error\")\n    return \"Success!\"\n\n# This will retry up to 3 times\nresult = unreliable_function()\n```\n\n**4. Authentication/Authorization Decorator:**\n```python\nfrom functools import wraps\n\n# Mock user system\ncurrent_user = {'role': 'admin', 'username': 'alice'}\n\ndef require_role(required_role):\n    \"\"\"Decorator factory for role-based access control\"\"\"\n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            if current_user.get('role') != required_role:\n                raise PermissionError(f\"Access denied. Required role: {required_role}\")\n            return func(*args, **kwargs)\n        return wrapper\n    return decorator\n\n@require_role('admin')\ndef delete_user(username):\n    return f\"User {username} deleted\"\n\n@require_role('user')\ndef view_profile():\n    return \"Profile data\"\n\n# This works (current_user is admin)\nprint(delete_user('bob'))\n\n# This would raise PermissionError if current_user wasn't admin\n```\n\n**5. Caching Decorator:**\n```python\nfrom functools import wraps\nimport hashlib\nimport json\n\ndef cache_result(expire_seconds=300):\n    \"\"\"Simple caching decorator\"\"\"\n    cache = {}\n    \n    def decorator(func):\n        @wraps(func)\n        def wrapper(*args, **kwargs):\n            # Create cache key from function name and arguments\n            key_data = f\"{func.__name__}:{args}:{sorted(kwargs.items())}\"\n            cache_key = hashlib.md5(key_data.encode()).hexdigest()\n            \n            # Check if result is cached and not expired\n            if cache_key in cache:\n                result, timestamp = cache[cache_key]\n                if time.time() - timestamp < expire_seconds:\n                    print(f\"Cache hit for {func.__name__}\")\n                    return result\n                else:\n                    del cache[cache_key]\n            \n            # Execute function and cache result\n            print(f\"Cache miss for {func.__name__}\")\n            result = func(*args, **kwargs)\n            cache[cache_key] = (result, time.time())\n            return result\n        \n        # Add cache management methods\n        wrapper.clear_cache = lambda: cache.clear()\n        wrapper.cache_info = lambda: f\"Cache size: {len(cache)}\"\n        \n        return wrapper\n    return decorator\n\n@cache_result(expire_seconds=60)\ndef expensive_calculation(n):\n    \"\"\"Simulate expensive computation\"\"\"\n    time.sleep(1)  # Simulate work\n    return sum(i ** 2 for i in range(n))\n\n# First call - cache miss\nresult1 = expensive_calculation(1000)\n\n# Second call - cache hit (much faster)\nresult2 = expensive_calculation(1000)\n```\n\n**Class-Based Decorators:**\n```python\nclass CountCalls:\n    \"\"\"Decorator class that counts function calls\"\"\"\n    \n    def __init__(self, func):\n        self.func = func\n        self.count = 0\n        # Preserve function metadata\n        self.__name__ = func.__name__\n        self.__doc__ = func.__doc__\n    \n    def __call__(self, *args, **kwargs):\n        self.count += 1\n        print(f\"{self.func.__name__} has been called {self.count} times\")\n        return self.func(*args, **kwargs)\n    \n    def reset_count(self):\n        self.count = 0\n\n@CountCalls\ndef greet(name):\n    return f\"Hello, {name}!\"\n\nprint(greet(\"Alice\"))  # Called 1 time\nprint(greet(\"Bob\"))    # Called 2 times\ngreet.reset_count()   # Reset counter\nprint(greet(\"Charlie\"))  # Called 1 time\n```\n\n**Multiple Decorators:**\n```python\n@timing_decorator\n@log_calls\n@cache_result(expire_seconds=30)\ndef complex_function(x, y):\n    \"\"\"Function with multiple decorators\"\"\"\n    time.sleep(0.1)  # Simulate work\n    return x ** y\n\n# Decorators are applied bottom-up:\n# complex_function = timing_decorator(log_calls(cache_result(complex_function)))\n\nresult = complex_function(2, 10)\n```\n\n**Property Decorators (Class methods):**\n```python\nclass Circle:\n    def __init__(self, radius):\n        self._radius = radius\n    \n    @property\n    def radius(self):\n        \"\"\"Getter for radius\"\"\"\n        return self._radius\n    \n    @radius.setter\n    def radius(self, value):\n        \"\"\"Setter for radius with validation\"\"\"\n        if value <= 0:\n            raise ValueError(\"Radius must be positive\")\n        self._radius = value\n    \n    @property\n    def area(self):\n        \"\"\"Computed property\"\"\"\n        return 3.14159 * self._radius ** 2\n    \n    @staticmethod\n    def from_diameter(diameter):\n        \"\"\"Alternative constructor\"\"\"\n        return Circle(diameter / 2)\n    \n    @classmethod\n    def unit_circle(cls):\n        \"\"\"Class method to create unit circle\"\"\"\n        return cls(1)\n\n# Usage\nc = Circle(5)\nprint(f\"Area: {c.area}\")  # Uses @property\nc.radius = 10  # Uses @setter\nunit = Circle.unit_circle()  # Uses @classmethod\n```\n\n**Best Practices:**\n\n1. **Always use `@wraps`** to preserve original function metadata\n2. **Handle `*args` and `**kwargs`** for flexibility\n3. **Consider using decorator factories** for parameterized decorators\n4. **Keep decorators simple** and focused on one responsibility\n5. **Document your decorators** clearly\n6. **Test decorated functions** thoroughly\n\nDecorators are incredibly powerful for cross-cutting concerns like logging, authentication, caching, and timing. Which specific use case are you interested in exploring further?"}]}
{"messages": [{"role": "system", "content": "You are an expert Python programmer and teacher. Provide clear, well-commented code examples with explanations."}, {"role": "user", "content": "How do I work with async/await in Python for concurrent programming?"}, {"role": "assistant", "content": "Async/await in Python enables concurrent programming, allowing you to handle I/O-bound operations efficiently! Let me walk you through the concepts and practical examples.\n\n**Basic Concepts:**\n\n**What is Async Programming?**\n- **Synchronous**: One task at a time, blocking execution\n- **Asynchronous**: Multiple tasks can run concurrently, non-blocking\n- Best for I/O-bound operations (network requests, file operations, database queries)\n\n**Key Terms:**\n- **Coroutine**: A function defined with `async def`\n- **Awaitable**: Something you can use `await` with\n- **Event Loop**: Manages and executes async tasks\n\n**1. Basic Async Function:**\n```python\nimport asyncio\nimport time\n\n# Regular synchronous function\ndef sync_task(name, duration):\n    print(f\"Starting {name}\")\n    time.sleep(duration)  # Blocking sleep\n    print(f\"Finished {name}\")\n    return f\"Result from {name}\"\n\n# Asynchronous coroutine\nasync def async_task(name, duration):\n    print(f\"Starting {name}\")\n    await asyncio.sleep(duration)  # Non-blocking sleep\n    print(f\"Finished {name}\")\n    return f\"Result from {name}\"\n\n# Running async functions\nasync def main():\n    # Run tasks concurrently\n    results = await asyncio.gather(\n        async_task(\"Task 1\", 2),\n        async_task(\"Task 2\", 1),\n        async_task(\"Task 3\", 3)\n    )\n    print(\"All results:\", results)\n\n# Execute the async main function\nif __name__ == \"__main__\":\n    asyncio.run(main())\n```\n\n**2. HTTP Requests with aiohttp:**\n```python\nimport aiohttp\nimport asyncio\nimport time\n\nasync def fetch_url(session, url):\n    \"\"\"Fetch a single URL asynchronously\"\"\"\n    try:\n        async with session.get(url) as response:\n            content = await response.text()\n            return {\n                'url': url,\n                'status': response.status,\n                'length': len(content)\n            }\n    except Exception as e:\n        return {'url': url, 'error': str(e)}\n\nasync def fetch_multiple_urls(urls):\n    \"\"\"Fetch multiple URLs concurrently\"\"\"\n    async with aiohttp.ClientSession() as session:\n        tasks = [fetch_url(session, url) for url in urls]\n        results = await asyncio.gather(*tasks)\n        return results\n\n# Compare sync vs async performance\ndef sync_fetch_urls(urls):\n    \"\"\"Synchronous version for comparison\"\"\"\n    import requests\n    results = []\n    for url in urls:\n        try:\n            response = requests.get(url)\n            results.append({\n                'url': url,\n                'status': response.status_code,\n                'length': len(response.text)\n            })\n        except Exception as e:\n            results.append({'url': url, 'error': str(e)})\n    return results\n\nasync def performance_comparison():\n    urls = [\n        'https://httpbin.org/delay/1',\n        'https://httpbin.org/delay/1',\n        'https://httpbin.org/delay/1',\n        'https://httpbin.org/delay/1'\n    ]\n    \n    # Async version\n    start_time = time.time()\n    async_results = await fetch_multiple_urls(urls)\n    async_duration = time.time() - start_time\n    \n    print(f\"Async version took: {async_duration:.2f} seconds\")\n    print(f\"Async results: {len(async_results)} responses\")\n    \n    # Note: Sync version would take ~4 seconds (sequential)\n    # Async version takes ~1 second (concurrent)\n```\n\n**3. Database Operations with asyncpg:**\n```python\nimport asyncpg\nimport asyncio\n\nclass AsyncDatabase:\n    def __init__(self, connection_string):\n        self.connection_string = connection_string\n        self.pool = None\n    \n    async def create_pool(self):\n        \"\"\"Create connection pool\"\"\"\n        self.pool = await asyncpg.create_pool(self.connection_string)\n    \n    async def close_pool(self):\n        \"\"\"Close connection pool\"\"\"\n        if self.pool:\n            await self.pool.close()\n    \n    async def fetch_user(self, user_id):\n        \"\"\"Fetch single user\"\"\"\n        async with self.pool.acquire() as conn:\n            return await conn.fetchrow(\n                \"SELECT * FROM users WHERE id = $1\", user_id\n            )\n    \n    async def fetch_multiple_users(self, user_ids):\n        \"\"\"Fetch multiple users concurrently\"\"\"\n        tasks = [self.fetch_user(user_id) for user_id in user_ids]\n        return await asyncio.gather(*tasks)\n    \n    async def create_user(self, username, email):\n        \"\"\"Create new user\"\"\"\n        async with self.pool.acquire() as conn:\n            return await conn.fetchrow(\n                \"INSERT INTO users (username, email) VALUES ($1, $2) RETURNING *\",\n                username, email\n            )\n\n# Usage example\nasync def database_operations():\n    db = AsyncDatabase(\"postgresql://user:pass@localhost/dbname\")\n    await db.create_pool()\n    \n    try:\n        # Concurrent database operations\n        users = await db.fetch_multiple_users([1, 2, 3, 4, 5])\n        print(f\"Fetched {len(users)} users concurrently\")\n        \n        # Create user\n        new_user = await db.create_user(\"john_doe\", \"john@example.com\")\n        print(f\"Created user: {new_user}\")\n        \n    finally:\n        await db.close_pool()\n```\n\n**4. File Operations:**\n```python\nimport aiofiles\nimport asyncio\nimport os\n\nasync def read_file_async(filename):\n    \"\"\"Read file asynchronously\"\"\"\n    try:\n        async with aiofiles.open(filename, 'r') as file:\n            content = await file.read()\n            return {'filename': filename, 'size': len(content), 'content': content[:100]}\n    except Exception as e:\n        return {'filename': filename, 'error': str(e)}\n\nasync def write_file_async(filename, content):\n    \"\"\"Write file asynchronously\"\"\"\n    async with aiofiles.open(filename, 'w') as file:\n        await file.write(content)\n        return f\"Written {len(content)} characters to {filename}\"\n\nasync def process_files_concurrently(filenames):\n    \"\"\"Process multiple files concurrently\"\"\"\n    # Read all files concurrently\n    read_tasks = [read_file_async(f) for f in filenames]\n    results = await asyncio.gather(*read_tasks)\n    \n    # Process and write results\n    write_tasks = []\n    for i, result in enumerate(results):\n        if 'content' in result:\n            processed_content = f\"Processed: {result['content'].upper()}\"\n            write_tasks.append(\n                write_file_async(f\"output_{i}.txt\", processed_content)\n            )\n    \n    if write_tasks:\n        write_results = await asyncio.gather(*write_tasks)\n        return write_results\n    \n    return []\n```\n\n**5. Producer-Consumer Pattern:**\n```python\nimport asyncio\nimport random\n\nasync def producer(queue, name, num_items):\n    \"\"\"Produce items and put them in queue\"\"\"\n    for i in range(num_items):\n        # Simulate work\n        await asyncio.sleep(random.uniform(0.1, 0.5))\n        \n        item = f\"{name}_item_{i}\"\n        await queue.put(item)\n        print(f\"Producer {name} created: {item}\")\n    \n    print(f\"Producer {name} finished\")\n\nasync def consumer(queue, name):\n    \"\"\"Consume items from queue\"\"\"\n    processed_count = 0\n    \n    while True:\n        try:\n            # Wait for item with timeout\n            item = await asyncio.wait_for(queue.get(), timeout=2.0)\n            \n            # Simulate processing\n            await asyncio.sleep(random.uniform(0.2, 0.8))\n            \n            print(f\"Consumer {name} processed: {item}\")\n            processed_count += 1\n            \n            # Mark task as done\n            queue.task_done()\n            \n        except asyncio.TimeoutError:\n            print(f\"Consumer {name} timed out, processed {processed_count} items\")\n            break\n\nasync def producer_consumer_example():\n    # Create queue with maximum size\n    queue = asyncio.Queue(maxsize=10)\n    \n    # Start producers and consumers\n    producers = [\n        asyncio.create_task(producer(queue, f\"Producer-{i}\", 5))\n        for i in range(2)\n    ]\n    \n    consumers = [\n        asyncio.create_task(consumer(queue, f\"Consumer-{i}\"))\n        for i in range(3)\n    ]\n    \n    # Wait for producers to finish\n    await asyncio.gather(*producers)\n    \n    # Wait for queue to be empty\n    await queue.join()\n    \n    # Cancel consumers\n    for c in consumers:\n        c.cancel()\n    \n    print(\"All items processed\")\n```\n\n**6. Error Handling and Timeouts:**\n```python\nimport asyncio\nimport aiohttp\n\nasync def robust_fetch(url, timeout=5):\n    \"\"\"Fetch URL with proper error handling and timeout\"\"\"\n    try:\n        async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=timeout)) as session:\n            async with session.get(url) as response:\n                if response.status == 200:\n                    content = await response.text()\n                    return {'success': True, 'url': url, 'content_length': len(content)}\n                else:\n                    return {'success': False, 'url': url, 'error': f'HTTP {response.status}'}\n    \n    except asyncio.TimeoutError:\n        return {'success': False, 'url': url, 'error': 'Timeout'}\n    except aiohttp.ClientError as e:\n        return {'success': False, 'url': url, 'error': f'Client error: {e}'}\n    except Exception as e:\n        return {'success': False, 'url': url, 'error': f'Unexpected error: {e}'}\n\nasync def fetch_with_semaphore(urls, max_concurrent=5):\n    \"\"\"Limit concurrent requests using semaphore\"\"\"\n    semaphore = asyncio.Semaphore(max_concurrent)\n    \n    async def bounded_fetch(url):\n        async with semaphore:\n            return await robust_fetch(url)\n    \n    tasks = [bounded_fetch(url) for url in urls]\n    return await asyncio.gather(*tasks)\n\n# Example usage\nasync def error_handling_example():\n    urls = [\n        'https://httpbin.org/status/200',\n        'https://httpbin.org/status/404', \n        'https://httpbin.org/delay/10',  # Will timeout\n        'https://invalid-url-that-does-not-exist.com'\n    ]\n    \n    results = await fetch_with_semaphore(urls, max_concurrent=2)\n    \n    for result in results:\n        if result['success']:\n            print(f\"✓ {result['url']}: {result['content_length']} bytes\")\n        else:\n            print(f\"✗ {result['url']}: {result['error']}\")\n```\n\n**7. Task Management:**\n```python\nimport asyncio\n\nasync def task_management_example():\n    \"\"\"Examples of task creation and management\"\"\"\n    \n    # Create and run tasks\n    async def worker(name, delay):\n        print(f\"Worker {name} starting\")\n        await asyncio.sleep(delay)\n        print(f\"Worker {name} finished\")\n        return f\"Result from {name}\"\n    \n    # Method 1: Create tasks individually\n    task1 = asyncio.create_task(worker(\"A\", 1))\n    task2 = asyncio.create_task(worker(\"B\", 2))\n    \n    # Wait for specific task\n    result1 = await task1\n    print(f\"First result: {result1}\")\n    \n    # Cancel remaining task if needed\n    if not task2.done():\n        task2.cancel()\n        try:\n            await task2\n        except asyncio.CancelledError:\n            print(\"Task2 was cancelled\")\n    \n    # Method 2: Run with timeout\n    try:\n        result = await asyncio.wait_for(worker(\"C\", 5), timeout=3.0)\n    except asyncio.TimeoutError:\n        print(\"Task C timed out\")\n    \n    # Method 3: Run multiple tasks with different strategies\n    tasks = [worker(f\"Worker-{i}\", i) for i in range(3)]\n    \n    # Wait for first completed\n    done, pending = await asyncio.wait(tasks, return_when=asyncio.FIRST_COMPLETED)\n    \n    print(f\"First completed: {done.pop().result()}\")\n    \n    # Cancel remaining\n    for task in pending:\n        task.cancel()\n```\n\n**Best Practices:**\n\n1. **Use `asyncio.run()` for main entry point**\n2. **Always use `async with` for resources** (sessions, files, connections)\n3. **Handle exceptions properly** in async code\n4. **Use semaphores** to limit concurrent operations\n5. **Don't mix blocking and async code** in the same function\n6. **Use `asyncio.gather()` for concurrent execution**\n7. **Consider using connection pools** for database operations\n8. **Test async code thoroughly** with different scenarios\n\n**When to Use Async:**\n- ✅ Network requests (API calls, web scraping)\n- ✅ Database operations\n- ✅ File I/O operations\n- ✅ WebSocket connections\n- ❌ CPU-intensive computations (use multiprocessing instead)\n- ❌ Simple, short-running scripts\n\nWhich specific async use case would you like to explore further - web APIs, database operations, or concurrent file processing?"}]}